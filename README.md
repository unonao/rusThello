# rusThello

## install
Rustのインストールのために、Unix系なら以下のコマンドを入力する

```
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```


## 使い方
```
USAGE:
    rusThello [FLAGS] [OPTIONS]

FLAGS:
        --cntntrain    continue train
        --debug        debug mode: level group
        --dotrain      do train
    -e, --eval         eval thinker
    -h, --help         Prints help information
        --info         info mode: level group
        --mktrain      make train data
        --nobook       do not use openning book
    -V, --version      Prints version information
        --verb         verbose mode: level group

OPTIONS:
    -B, --beta <BETA>            train beta [default: 0.003]
    -E, --endtrain <ENDTRAIN>    end train [default: 13]
    -H, --host <HOST>            host ip address [default: 127.0.0.1]
    -I, --iter <ITER>            train iterate num [default: 100]
    -n, --name <NAME>            player name [default: rusThello]
    -p, --port <PORT>            port number [default: 3000]
    -s, --solve <SOLVE>          start solver depth [default: 12]
    -S, --sttrain <STTRAIN>      start train [default: 2]
    -t, --think <THINK>          think depth [default: 4]
```

対戦モード
(rusThelloディレクトリで以下のコマンドを使用する)
```
cargo run --release -- -H "127.0.0.1" -p 3000 -n rusThello -s 22 -t 9
```
時間がかかり過ぎる場合は、「-s」,「-t」の値を減らしてください。
randomへの勝率はほぼ100％。


学習したモデルの使用は名前を「evalTest」に変更する（強くない）
```
cargo run --release -- -H "127.0.0.1" -p 3000 -n evalTest
```
（提出用のファイルの制限が1MBだったので、学習済みmodelデータは送れなかった。圧縮せずに4MB以内だが、圧縮しても1MB以上であった）


## Crate
### nom
parserのために、nom(version 5.0.0)を使用した。
### rand
rand = "0.7.0"
### lazy_static
lazy_static = "1.3.0"
### clap
コマンドライン引数の使用
### serde
構造体の保存用
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
### flate
modelデータの圧縮・解凍用
flate2 = "1.0"


## ディレクトリ構成

bookディレクトリ(オープニングブック用)

dataディレクトリ(オープニングブック・モデル学習用のデータ。提出ファイルからは削除)

modelディレクトリ(学習済みモデルのファイル)

srcディレクトリ(ソースコード一式)
- book.rs: 序盤の手をbookから探索するファイル
- color.rs: 黒や白などの、石の色に関するファイル
- command_parser.rs: プロトコルで定められたメッセージをパースする関数や、構造体・列挙型を定義するファイル
- eval_fun.rs: モデルを使用した評価に必要な関数を集めたファイル
- eval.rs: 盤面評価をするファイル
- global.rs: グローバル変数用のファイル
- hash.rs: HashMapを使用して、探索結果を保存するためのファイル
- lib.rs
- main.rs
- make_train_data.rs: dataディレクトリ内に存在するデータをtrainディレクトリ内のpre_train_data.cppで処理したものを、さらに学習用に整形するためのファイル
- play.rs: オセロ用の基本関数やBoard構造体についてのファイル
- print.rs : print系の出力用関数を集めたファイル
- rotate.rs: bitboardの回転や反転用の関数を集めたファイル
- solver.rs: 終盤ソルバー用のファイル
- think.rs: 思考ルーチン用ファイル
- train.rs: モデルの学習に必要なファイル

trainディレクトリ(src/make_train_data.rsで生成したtrainデータの保管)


提出ファイルの合計は約2.5MBなので、レギュレーションの4MB以内に収まっている。
しかし、modelのデータを含めると、圧縮しても1MBを超えてしまうので、学習済みデータは送らなかった。


## Openning book
Logistelloの棋譜データ(https://skatgame.net/mburo/log.htmlより)をもとに、序盤に似たような手を見つけたら、最も評価値が高い手を打つようにした。
これにより、前半21手分は、同様の棋譜が現れた場合、有力な手をうつことができる。

dataディレクトリ内のデータを、bookディレクトリ内のcompose.cppではじめから21手までの棋譜データを抽出した。
本来なら40手分ほどのデータが欲しかった(終盤20手なら読み切れるため)が、
棋譜データを探索するために必要なBTreeMapはStringにたいしてRangeメソッドを使用できなかったので、
u128に収まるように前半21手分のデータを保存した。（1手は8*8通りのどれかなので、合計6bitsで表すことができる）

book.rs内でBTreeMapへのinsertや検索などの関数を定義した。

棋譜データはすべてd3から打った手で始まっているので、
もしも別の場所からゲームが始まった場合は対称性を利用して、盤面を回転させてd3から始まったのと同じ扱いにしないとopenning bookの検索ができない。
よって、自分の打った手を回転させて、「HIST」というグローバル変数にu128の値として保存した。
探索は「HIST」の値を使用して、BTreeMap内を探索する。



## Board
ファイルはplay.rs
bit boardで実装。
`u64`型２つで定義されたBoard構造体に対して、メソッドを定義することで基本的な操作を行う。

黒石と空きマスをu64で表し、
白石と空きますをu64で表す。
すると、u64型の整数2つで、盤面を表すことが可能になる。
単純に8＊8の配列を用意するよりも、bit boardはビット演算を行うことで高速な計算をすることができる。

### flip(ひっくり返る石の数)
flippable_stones関数を参照。
着手位置から見たそれぞれの方向についてマスクをとり、自身の石が連続する相手の石の先にあるかを判定。
石がある場合は、挟まれた部分をビット演算を活用して取得する。

8方向を確認する必要があり、上、左、左上、右上のコード内容はほぼ同じであり（マスクが違う）、
着手位置からみて相手の石が途切れたところをleading_zeros()で求め、自分の石の位置とandを取ることでひっくり返せるかどうかがわかる。
下、右、右下、左下のコード内容もほぼ同じで、関係ない場所を1で埋めてから+1をすることで、下位ビットから見て相手の石が途切れたところを探す。

4つずつ並列計算ができるならば、少し変更すればさらに高速化できる。SIMD命令を使って高速することもできると考えられる。

はじめに実装した際は(play.rs内のold_flippable_stones関数)、mobilityの計算と同様にビットシフトを繰り返して相手の石の場所を伝播させていったが、
現在の実装に比べると計算に時間がかかるので、高速化のために変更した。


### mobility(着手位置の判定)
8方向それぞれについて、ビットシフトを繰り返して相手の石が連続する部分を伝播させていき、blankとの論理積を取れば良い。
無駄な関数呼び出しをなくして高速化した。
石を置くと左に向かって相手の石をひっくり返せるような位置に関しては、
```
p1 = p << 1;
 ~(p1 | o) & (p1 + o);
```
とすると、一気に計算ができる。

ビットボードを回転させるなどして、同様の計算を8方向に関して行うこともできるが、
回転するのにも計算時間がかかることが予想されるので、大きな違いは無いと考えて実装しなかった。


### 細かい高速化の工夫
Board構造体のメソッドに変更した関数のうちいくつかは、if文で何度も自身のboardがBLACKかWHITEか判定していたので、
一度判定してから、playerのboardとopponentのboardを引数にして関数を実行するように変更した。



## 評価関数の実装
ファイルはeval.rsを参照

### 人力で決定したパラメータを用いる評価関数
はじめは、角や辺は得点が高く、角の周囲はマイナスの得点になるような簡単な評価関数を実装した。

序盤は自身の石が少ないほうが有利だという定石があるので、
途中までは自身の石が少ないほうが高得点になるように変更したところ勝率が上がった。

終盤は、角の重要性というのはそれほど大きくないので、角や辺の特典を序盤よりも小さくして、
自身の石の数が多いほうが得点が大きくなるように変更した。

### model
ファイルはmake_train_data.rs, eval_fun.rs, train.rsを参照。

盤面上の石の配置データの情報をパターンとして、教師あり学習によってパターンごとに重みを決定し、
線形和によって最終的な石の数の差を予測するモデルを作成した。

全60手を5手ずつ12のステージに分けて、ステージごとに別のモデルを作成した。

棋譜データはLogistelloの棋譜データを使用。12万棋譜ほど。
最小二乗法を元に、最急降下法を用いて重みを決定した。

しかし、それほど強くならなかった。パターンの数に対して、棋譜データの数が少なかったことが原因だと考えられる。

modelデータは普通にファイルに保存すると、レギュレーションの4MBを軽く超えてしまう。
なので、一度モデル用の構造体をJson形式の文字列に変換して圧縮し、ファイルに保存することにした。
実際にモデルを使用する際は、ファイルをコード内で読み込んでから解凍する。


### 探索アルゴリズム
think.rsファイルを参照。

自分が最大利益となる手を打ち、相手がこちらの利益が最小となるような手を打つような、簡単なminimaxを実装した。
その後、余分な探索をなくす（枝刈りをする）ために、α-β法を実装した。

modelの評価は、通常の評価関数よりも時間がかかるので、多少時間がかかっても多くの枝刈りをしたほうが良い。
なので、negascout法を実装した。さらに簡単なmove_orderingもできるようにした。



## 終盤solver
ファイルはsolver.rs
終盤ソルバーを実装。
`--release`オプションをつければ、高速に計算できる。
実際に使う場合は22~24手読み前後まで可能(マシンに依る)。

### 速さ優先探索
相手が打てる候補が少なくなるような手から探索する。
これによって、必ず勝利することができる手が見つかった場合は、探索を終了するので、
探索時間の大幅なカットをすることができる。

### 最終1手最適化
参考: http://sealsoft.jp/thell/algorithm.html
によると、通常の着手の処理を行わず、返る石の数だけを数えて最終結果を求めるという最終1手最適化をしたほうが早くなる。
参考サイトとは違いbitboardでの実装をしているので、通常の着手の処理を行うことになるが、
余分な条件分岐を加えるだけで、通常どおりに関数を呼び出すよりも高速化ができる。

### 最終2手最適化
残り2手のときは、ベクトルを作ってイテレートさせるのはコストパフォーマンスが悪いので、
直接条件分岐と再帰関数呼び出しを行う。

### 置換表(ソルバーにハッシュの導入)
探索結果を置換表に入れておくことで、同じ盤面が登場した際に計算し直す手間がなくなるので、高速化できると考えられる。

https://doc.rust-jp.rs/book/second-edition/ch08-03-hash-maps.html
3次元配列hash_mask[2][8][256(8bit)]の作成
1つ目: 打ち手のボードが相手のボードか
2つ目: u64を8bitずつ区切って、何個目か
3つ目: 区切った8bitの値
それぞれに、乱数を格納しておく。(乱数はu64の範囲)

hasherにhash_maskの値をもとにxorしたものを入れて、hashmapに格納or checkする。

しかし、あまり効果はなかった。
ロックしているため並列計算がうまく行かないことや、置換表の実行にコストがかかってしまうこと、同じ盤面が登場することが終盤は少ないことなど原因としてが考えられる。
