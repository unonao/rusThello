# rusThello

## Todo
### ソルバーにハッシュの導入
https://doc.rust-jp.rs/book/second-edition/ch08-03-hash-maps.html

### SIMD命令を使う
(使えるコンピュータなら)
Linuxなら
```
cat /proc/cpuinfo
```
で確認
https://doc.rust-lang.org/1.27.2/std/arch/index.html
参考: https://qiita.com/termoshtt/items/a1d3af42bc01c88273c8

### 評価関数の実装

### α-β法の実装

## install
Rustのインストールのために、Unix系なら以下のコマンドを入力する

```
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```


## nom
parserのために、nom(version 5.0.0)を使用した。

## ディレクトリ構成
srcディレクトリにソースコード一式がある。
- color.rs: 黒や白などの、石の色に関するファイル
- command_parser.rs: プロトコルで定められたメッセージをパースする関数や、構造体・列挙型を定義するファイル
- main.rs
- play.rs: オセロ用の基本関数やBoard構造体についてのファイル
- print.rs : print系の出力用関数を集めたファイル
- solver.rs: 終盤ソルバー用のファイル
- think.rs: 思考ルーチン用ファイル

## 実装
### Board
ファイルはplay.rs
bit boardで実装。
`u64`型２つで定義されたBoard構造体に対して、メソッドを定義することで基本的な操作を行う。

#### flip(ひっくり返る石の数)
着手位置から見たそれぞれの方向についてマスクをとり、自身の石が連続する相手の石の先にあるかを判定。
ある場合は、挟まれた部分をビット演算を活用して取得する。
8方向を確認する必要があり、上、左、左上、右上のコード内容はほぼ同じであり（マスクが違う）、
下、右、右下、左下のコード内容もほぼ同じである。
4つずつ並列計算ができるならば、少し変更すればさらに高速化できる。

はじめはmobilityの計算と同様に、ビットシフトを繰り返して相手の石の場所を伝播させていったが、
計算に時間がかかるので、高速化のために変更した。

#### mobility(着手位置の判定)
8方向それぞれについて、ビットシフトを繰り返して相手の石が連続する部分を伝播させていき、blankとの論理積を取れば良い。
無駄な関数呼び出しをなくして高速化した。
石を置くと左に向かって相手の石をひっくり返せるような位置に関しては、
```
p1 = p << 1;
 ~(p1 | o) & (p1 + o);
```
とすると、一気に計算ができる。

ビットボードを回転させるなどして、同様の計算を8方向に関して行うこともできるが、
回転するのにも計算時間がかかる上に、実装が手間なので今回は見送った。


####細かい高速化の工夫
Board構造体のメソッドに変更した関数のうちいくつかは、if文で何度も自身のboardがBLACKかWHITEか判定していたので、
一度判定してから、playerのboardとopponentのboardを引数にして関数を実行するように変更した。



### solver
ファイルはsolver.rs
終盤ソルバーを実装。

#### 速さ優先探索
相手が打てる候補が少なくなるような手から探索する。
反転数を何度も計算するので、専用のメソッドflippable_countを用意した。
内容は、flippable_stonesとほぼ同じである。

`--release`オプションをつければ、高速に計算できる。
実際に使う場合は21手読み前後まで可能。(50回試してworstが14.315秒)
```
count:21  0.000秒経過しました。
count:21  3.704秒経過しました。
count:21  0.449秒経過しました。
count:21  0.024秒経過しました。
count:21  14.315秒経過しました。
```

#### 最終1手最適化
参考: http://sealsoft.jp/thell/algorithm.html
によると、通常の着手の処理を行わず、返る石の数だけを数えて最終結果を求めるという最終1手最適化をしたほうが早くなる。
参考サイトとは違いbitboardでの実装をしているので、通常の着手の処理を行うことになるが、
余分な条件分岐を加えるだけで、通常どおりに関数を呼び出すよりも高速化ができる。
