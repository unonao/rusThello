# rusThello

## install
Rustのインストールのために、Unix系なら以下のコマンドを入力する

```
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```


## nom
parserのために、nom(version 5.0.0)を使用した。

## ディレクトリ構成
srcディレクトリにソースコード一式がある。
- color.rs: 黒や白などの、石の色に関するファイル
- command_parser.rs: プロトコルで定められたメッセージをパースする関数や、構造体・列挙型を定義するファイル
- main.rs
- play.rs: オセロ用の基本関数やBoard構造体についてのファイル
- print.rs : print系の出力用関数を集めたファイル
- solver.rs: 終盤ソルバー用のファイル
- think.rs: 思考ルーチン用ファイル

## 実装
### Board
ファイルはplay.rs
bit boardで実装。
`u64`型２つで定義されたBoard構造体に対して、メソッドを定義することで基本的な操作を行う。

#### flip(ひっくり返る石の数)
着手位置から見たそれぞれの方向についてマスクをとり、自身の石が連続する相手の石の先にあるかを判定。
ある場合は、挟まれた部分をビット演算を活用して取得する。
8方向を確認する必要があり、上、左、左上、右上のコード内容はほぼ同じであり（マスクが違う）、
下、右、右下、左下のコード内容もほぼ同じである。
4つずつ並列計算ができるならば、少し変更すればさらに高速化できる。

はじめはmobilityの計算と同様に、ビットシフトを繰り返して相手の石の場所を伝播させていったが、
計算に時間がかかるので、高速化のために変更した。

#### mobility(着手位置の判定)
8方向それぞれについて、ビットシフトを繰り返して相手の石が連続する部分を伝播させていき、blankとの論理積を取れば良い。
無駄な関数呼び出しをなくして高速化した。
石を置くと左に向かって相手の石をひっくり返せるような位置に関しては、
```
p1 = p << 1;
 ~(p1 | o) & (p1 + o);
```
とすると、一気に計算ができる。

ビットボードを回転させるなどして、同様の計算を8方向に関して行うこともできるが、
回転するのにも計算時間がかかる上に、実装が手間なので今回は見送った。


### solver
ファイルはsolver.rs
終盤ソルバーを実装。速さ優先探索で走査。

現在は16手読みに数秒程度。50回やってworstが6.999秒
`--release`オプションをつければ、ほぼ1秒以内に押さまる。

実際に使う場合は19手読みほどまで可能。


勝てればtrue，それ以外はfalseで返すようにしているので、石数の差が得られるように改良する必要あり。
flip_boardに関して、返り値を石数の差にするなど...？
